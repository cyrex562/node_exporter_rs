use prost::Message;
use std::collections::HashMap;
const _: () = {
    // Verify that this generated code is sufficiently up-to-date.
    const ENFORCE_VERSION: i32 = 20 - MIN_VERSION;
    // Verify that runtime/protoimpl is sufficiently up-to-date.
    const ENFORCE_RUNTIME_VERSION: i32 = MAX_VERSION - 20;
};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum MetricType {
    Counter = 0,
    Gauge = 1,
    Summary = 2,
    Untyped = 3,
    Histogram = 4,
}

lazy_static::lazy_static! {
    pub static ref METRIC_TYPE_NAME: HashMap<i32, &'static str> = {
        let mut m = HashMap::new();
        m.insert(0, "COUNTER");
        m.insert(1, "GAUGE");
        m.insert(2, "SUMMARY");
        m.insert(3, "UNTYPED");
        m.insert(4, "HISTOGRAM");
        m.insert(5, "GAUGE_HISTOGRAM");
        m
    };

    pub static ref METRIC_TYPE_VALUE: HashMap<&'static str, i32> = {
        let mut m = HashMap::new();
        m.insert("COUNTER", 0);
        m.insert("GAUGE", 1);
        m.insert("SUMMARY", 2);
        m.insert("UNTYPED", 3);
        m.insert("HISTOGRAM", 4);
        m.insert("GAUGE_HISTOGRAM", 5);
        m
    };
}

impl MetricType {
    pub fn enum_ref(&self) -> &MetricType {
        self
    }

    pub fn to_string(&self) -> &'static str {
        match self {
            MetricType::Counter => "COUNTER",
            MetricType::Gauge => "GAUGE",
            MetricType::Summary => "SUMMARY",
            MetricType::Untyped => "UNTYPED",
            MetricType::Histogram => "HISTOGRAM",
            MetricType::GaugeHistogram => "GAUGE_HISTOGRAM",
        }
    }

    pub fn descriptor(&self) -> &'static str {
        "MetricType"
    }

    pub fn number(&self) -> i32 {
        *self as i32
    }

    pub fn from_number(num: i32) -> Option<MetricType> {
        match num {
            0 => Some(MetricType::Counter),
            1 => Some(MetricType::Gauge),
            2 => Some(MetricType::Summary),
            3 => Some(MetricType::Untyped),
            4 => Some(MetricType::Histogram),
            5 => Some(MetricType::GaugeHistogram),
            _ => None,
        }
    }
}

// Deprecated: Do not use.
impl serde::Deserialize for MetricType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let num: i32 = serde::Deserialize::deserialize(deserializer)?;
        MetricType::from_number(num).ok_or_else(|| serde::de::Error::custom("invalid MetricType"))
    }
}

// Deprecated: Use MetricType::descriptor instead.
impl MetricType {
    pub fn enum_descriptor() -> (&'static [u8], [usize; 1]) {
        (b"MetricType", [0])
    }
}

#[derive(Clone, PartialEq, Message)]
pub struct LabelPair {
    #[prost(string, optional, tag = "1")]
    pub name: Option<String>,
    #[prost(string, optional, tag = "2")]
    pub value: Option<String>,
}

impl LabelPair {
    pub fn reset(&mut self) {
        *self = LabelPair::default();
    }

    pub fn get_name(&self) -> &str {
        self.name.as_deref().unwrap_or("")
    }

    pub fn get_value(&self) -> &str {
        self.value.as_deref().unwrap_or("")
    }
}

impl std::fmt::Debug for LabelPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "LabelPair {{ name: {:?}, value: {:?} }}",
            self.name, self.value
        )
    }
}

impl std::fmt::Display for LabelPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "LabelPair {{ name: {:?}, value: {:?} }}",
            self.name, self.value
        )
    }
}

impl Default for LabelPair {
    fn default() -> Self {
        LabelPair {
            name: None,
            value: None,
        }
    }
}

#[derive(Clone, PartialEq, Message)]
pub struct Gauge {
    #[prost(double, optional, tag = "1")]
    pub value: Option<f64>,
}

impl Gauge {
    pub fn reset(&mut self) {
        *self = Gauge::default();
    }

    pub fn get_value(&self) -> f64 {
        self.value.unwrap_or(0.0)
    }
}

impl std::fmt::Debug for Gauge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Gauge {{ value: {:?} }}", self.value)
    }
}

impl std::fmt::Display for Gauge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Gauge {{ value: {:?} }}", self.value)
    }
}

impl Default for Gauge {
    fn default() -> Self {
        Gauge { value: None }
    }
}

#[derive(Clone, PartialEq, Message)]
pub struct Counter {
    #[prost(double, optional, tag = "1")]
    pub value: Option<f64>,
    #[prost(message, optional, tag = "2")]
    pub exemplar: Option<Exemplar>,
    #[prost(message, optional, tag = "3", rename = "created_timestamp")]
    pub created_timestamp: Option<Timestamp>,
}

impl Counter {
    pub fn reset(&mut self) {
        *self = Counter::default();
    }

    pub fn get_value(&self) -> f64 {
        self.value.unwrap_or(0.0)
    }

    pub fn get_exemplar(&self) -> Option<&Exemplar> {
        self.exemplar.as_ref()
    }

    pub fn get_created_timestamp(&self) -> Option<&Timestamp> {
        self.created_timestamp.as_ref()
    }
}

impl std::fmt::Debug for Counter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "Counter {{ value: {:?}, exemplar: {:?}, created_timestamp: {:?} }}",
            self.value, self.exemplar, self.created_timestamp
        )
    }
}

impl std::fmt::Display for Counter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "Counter {{ value: {:?}, exemplar: {:?}, created_timestamp: {:?} }}",
            self.value, self.exemplar, self.created_timestamp
        )
    }
}

impl Default for Counter {
    fn default() -> Self {
        Counter {
            value: None,
            exemplar: None,
            created_timestamp: None,
        }
    }
}

#[derive(Clone, PartialEq, Message)]
pub struct Quantile {
    #[prost(double, optional, tag = "1")]
    pub quantile: Option<f64>,
    #[prost(double, optional, tag = "2")]
    pub value: Option<f64>,
}

impl Quantile {
    pub fn reset(&mut self) {
        *self = Quantile::default();
    }

    pub fn get_quantile(&self) -> f64 {
        self.quantile.unwrap_or(0.0)
    }

    pub fn get_value(&self) -> f64 {
        self.value.unwrap_or(0.0)
    }
}

impl std::fmt::Debug for Quantile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "Quantile {{ quantile: {:?}, value: {:?} }}",
            self.quantile, self.value
        )
    }
}

impl std::fmt::Display for Quantile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "Quantile {{ quantile: {:?}, value: {:?} }}",
            self.quantile, self.value
        )
    }
}

impl Default for Quantile {
    fn default() -> Self {
        Quantile {
            quantile: None,
            value: None,
        }
    }
}

#[derive(Clone, PartialEq, Message)]
pub struct Summary {
    #[prost(uint64, optional, tag = "1")]
    pub sample_count: Option<u64>,
    #[prost(double, optional, tag = "2")]
    pub sample_sum: Option<f64>,
    #[prost(message, repeated, tag = "3")]
    pub quantile: Vec<Quantile>,
    #[prost(message, optional, tag = "4", rename = "created_timestamp")]
    pub created_timestamp: Option<Timestamp>,
}

impl Summary {
    pub fn reset(&mut self) {
        *self = Summary::default();
    }

    pub fn get_sample_count(&self) -> u64 {
        self.sample_count.unwrap_or(0)
    }

    pub fn get_sample_sum(&self) -> f64 {
        self.sample_sum.unwrap_or(0.0)
    }

    pub fn get_quantile(&self) -> &Vec<Quantile> {
        &self.quantile
    }

    pub fn get_created_timestamp(&self) -> Option<&Timestamp> {
        self.created_timestamp.as_ref()
    }
}

impl std::fmt::Debug for Summary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Summary {{ sample_count: {:?}, sample_sum: {:?}, quantile: {:?}, created_timestamp: {:?} }}", self.sample_count, self.sample_sum, self.quantile, self.created_timestamp)
    }
}

impl std::fmt::Display for Summary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Summary {{ sample_count: {:?}, sample_sum: {:?}, quantile: {:?}, created_timestamp: {:?} }}", self.sample_count, self.sample_sum, self.quantile, self.created_timestamp)
    }
}

impl Default for Summary {
    fn default() -> Self {
        Summary {
            sample_count: None,
            sample_sum: None,
            quantile: Vec::new(),
            created_timestamp: None,
        }
    }
}

#[derive(Clone, PartialEq, Message)]
pub struct Untyped {
    #[prost(double, optional, tag = "1")]
    pub value: Option<f64>,
}

impl Untyped {
    pub fn reset(&mut self) {
        *self = Untyped::default();
    }

    pub fn get_value(&self) -> f64 {
        self.value.unwrap_or(0.0)
    }
}

impl Default for Untyped {
    fn default() -> Self {
        Untyped { value: None }
    }
}

impl std::fmt::Debug for Untyped {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Untyped {{ value: {:?} }}", self.value)
    }
}

use prost::Message;
use prost_types::Timestamp;

#[derive(Clone, PartialEq, Message)]
pub struct Histogram {
    #[prost(uint64, optional, tag = "1")]
    pub sample_count: Option<u64>,
    #[prost(double, optional, tag = "4")]
    pub sample_count_float: Option<f64>,
    #[prost(double, optional, tag = "2")]
    pub sample_sum: Option<f64>,
    #[prost(message, repeated, tag = "3")]
    pub bucket: Vec<Bucket>,
    #[prost(message, optional, tag = "15")]
    pub created_timestamp: Option<Timestamp>,
    #[prost(sint32, optional, tag = "5")]
    pub schema: Option<i32>,
    #[prost(double, optional, tag = "6")]
    pub zero_threshold: Option<f64>,
    #[prost(uint64, optional, tag = "7")]
    pub zero_count: Option<u64>,
    #[prost(double, optional, tag = "8")]
    pub zero_count_float: Option<f64>,
    #[prost(message, repeated, tag = "9")]
    pub negative_span: Vec<BucketSpan>,
    #[prost(sint64, repeated, tag = "10")]
    pub negative_delta: Vec<i64>,
    #[prost(double, repeated, tag = "11")]
    pub negative_count: Vec<f64>,
    #[prost(message, repeated, tag = "12")]
    pub positive_span: Vec<BucketSpan>,
    #[prost(sint64, repeated, tag = "13")]
    pub positive_delta: Vec<i64>,
    #[prost(double, repeated, tag = "14")]
    pub positive_count: Vec<f64>,
    #[prost(message, repeated, tag = "16")]
    pub exemplars: Vec<Exemplar>,
}

impl Histogram {
    pub fn reset(&mut self) {
        *self = Histogram::default();
    }

    pub fn get_sample_count(&self) -> u64 {
        self.sample_count.unwrap_or(0)
    }

    pub fn get_sample_count_float(&self) -> f64 {
        self.sample_count_float.unwrap_or(0.0)
    }

    pub fn get_sample_sum(&self) -> f64 {
        self.sample_sum.unwrap_or(0.0)
    }

    pub fn get_bucket(&self) -> &Vec<Bucket> {
        &self.bucket
    }

    pub fn get_created_timestamp(&self) -> Option<&Timestamp> {
        self.created_timestamp.as_ref()
    }

    pub fn get_schema(&self) -> i32 {
        self.schema.unwrap_or(0)
    }

    pub fn get_zero_threshold(&self) -> f64 {
        self.zero_threshold.unwrap_or(0.0)
    }

    pub fn get_zero_count(&self) -> u64 {
        self.zero_count.unwrap_or(0)
    }

    pub fn get_zero_count_float(&self) -> f64 {
        self.zero_count_float.unwrap_or(0.0)
    }

    pub fn get_negative_span(&self) -> &Vec<BucketSpan> {
        &self.negative_span
    }

    pub fn get_negative_delta(&self) -> &Vec<i64> {
        &self.negative_delta
    }

    pub fn get_negative_count(&self) -> &Vec<f64> {
        &self.negative_count
    }

    pub fn get_positive_span(&self) -> &Vec<BucketSpan> {
        &self.positive_span
    }

    pub fn get_positive_delta(&self) -> &Vec<i64> {
        &self.positive_delta
    }

    pub fn get_positive_count(&self) -> &Vec<f64> {
        &self.positive_count
    }

    pub fn get_exemplars(&self) -> &Vec<Exemplar> {
        &self.exemplars
    }
}

impl Default for Histogram {
    fn default() -> Self {
        Histogram {
            sample_count: None,
            sample_count_float: None,
            sample_sum: None,
            bucket: Vec::new(),
            created_timestamp: None,
            schema: None,
            zero_threshold: None,
            zero_count: None,
            zero_count_float: None,
            negative_span: Vec::new(),
            negative_delta: Vec::new(),
            negative_count: Vec::new(),
            positive_span: Vec::new(),
            positive_delta: Vec::new(),
            positive_count: Vec::new(),
            exemplars: Vec::new(),
        }
    }
}

impl std::fmt::Debug for Histogram {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Histogram {{ sample_count: {:?}, sample_count_float: {:?}, sample_sum: {:?}, bucket: {:?}, created_timestamp: {:?}, schema: {:?}, zero_threshold: {:?}, zero_count: {:?}, zero_count_float: {:?}, negative_span: {:?}, negative_delta: {:?}, negative_count: {:?}, positive_span: {:?}, positive_delta: {:?}, positive_count: {:?}, exemplars: {:?} }}",
            self.sample_count, self.sample_count_float, self.sample_sum, self.bucket, self.created_timestamp, self.schema, self.zero_threshold, self.zero_count, self.zero_count_float, self.negative_span, self.negative_delta, self.negative_count, self.positive_span, self.positive_delta, self.positive_count, self.exemplars)
    }
}

use prost::Message;

#[derive(Clone, PartialEq, Message)]
pub struct Bucket {
    #[prost(uint64, optional, tag = "1")]
    pub cumulative_count: Option<u64>,
    #[prost(double, optional, tag = "4")]
    pub cumulative_count_float: Option<f64>,
    #[prost(double, optional, tag = "2")]
    pub upper_bound: Option<f64>,
    #[prost(message, optional, tag = "3")]
    pub exemplar: Option<Exemplar>,
}

impl Bucket {
    pub fn reset(&mut self) {
        *self = Bucket::default();
    }

    pub fn get_cumulative_count(&self) -> u64 {
        self.cumulative_count.unwrap_or(0)
    }

    pub fn get_cumulative_count_float(&self) -> f64 {
        self.cumulative_count_float.unwrap_or(0.0)
    }

    pub fn get_upper_bound(&self) -> f64 {
        self.upper_bound.unwrap_or(0.0)
    }

    pub fn get_exemplar(&self) -> Option<&Exemplar> {
        self.exemplar.as_ref()
    }
}

impl Default for Bucket {
    fn default() -> Self {
        Bucket {
            cumulative_count: None,
            cumulative_count_float: None,
            upper_bound: None,
            exemplar: None,
        }
    }
}

impl std::fmt::Debug for Bucket {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Bucket {{ cumulative_count: {:?}, cumulative_count_float: {:?}, upper_bound: {:?}, exemplar: {:?} }}",
            self.cumulative_count, self.cumulative_count_float, self.upper_bound, self.exemplar)
    }
}

use prost::Message;

#[derive(Clone, PartialEq, Message)]
pub struct BucketSpan {
    #[prost(sint32, optional, tag = "1")]
    pub offset: Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub length: Option<u32>,
}

impl BucketSpan {
    pub fn reset(&mut self) {
        *self = BucketSpan::default();
    }

    pub fn get_offset(&self) -> i32 {
        self.offset.unwrap_or(0)
    }

    pub fn get_length(&self) -> u32 {
        self.length.unwrap_or(0)
    }
}

impl Default for BucketSpan {
    fn default() -> Self {
        BucketSpan {
            offset: None,
            length: None,
        }
    }
}

impl std::fmt::Debug for BucketSpan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "BucketSpan {{ offset: {:?}, length: {:?} }}",
            self.offset, self.length
        )
    }
}

use prost::Message;
use prost_types::Timestamp;

#[derive(Clone, PartialEq, Message)]
pub struct Exemplar {
    #[prost(message, repeated, tag = "1")]
    pub label: Vec<LabelPair>,
    #[prost(double, optional, tag = "2")]
    pub value: Option<f64>,
    #[prost(message, optional, tag = "3")]
    pub timestamp: Option<Timestamp>,
}

impl Exemplar {
    pub fn reset(&mut self) {
        *self = Exemplar::default();
    }

    pub fn get_label(&self) -> &Vec<LabelPair> {
        &self.label
    }

    pub fn get_value(&self) -> f64 {
        self.value.unwrap_or(0.0)
    }

    pub fn get_timestamp(&self) -> Option<&Timestamp> {
        self.timestamp.as_ref()
    }
}

impl Default for Exemplar {
    fn default() -> Self {
        Exemplar {
            label: Vec::new(),
            value: None,
            timestamp: None,
        }
    }
}

impl std::fmt::Debug for Exemplar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "Exemplar {{ label: {:?}, value: {:?}, timestamp: {:?} }}",
            self.label, self.value, self.timestamp
        )
    }
}

use prost::Message;

#[derive(Clone, PartialEq, Message)]
pub struct Metric {
    #[prost(message, repeated, tag = "1")]
    pub label: Vec<LabelPair>,
    #[prost(message, optional, tag = "2")]
    pub gauge: Option<Gauge>,
    #[prost(message, optional, tag = "3")]
    pub counter: Option<Counter>,
    #[prost(message, optional, tag = "4")]
    pub summary: Option<Summary>,
    #[prost(message, optional, tag = "5")]
    pub untyped: Option<Untyped>,
    #[prost(message, optional, tag = "7")]
    pub histogram: Option<Histogram>,
    #[prost(int64, optional, tag = "6")]
    pub timestamp_ms: Option<i64>,
}

impl Metric {
    pub fn reset(&mut self) {
        *self = Metric::default();
    }

    pub fn get_label(&self) -> &Vec<LabelPair> {
        &self.label
    }

    pub fn get_gauge(&self) -> Option<&Gauge> {
        self.gauge.as_ref()
    }

    pub fn get_counter(&self) -> Option<&Counter> {
        self.counter.as_ref()
    }

    pub fn get_summary(&self) -> Option<&Summary> {
        self.summary.as_ref()
    }

    pub fn get_untyped(&self) -> Option<&Untyped> {
        self.untyped.as_ref()
    }

    pub fn get_histogram(&self) -> Option<&Histogram> {
        self.histogram.as_ref()
    }

    pub fn get_timestamp_ms(&self) -> i64 {
        self.timestamp_ms.unwrap_or(0)
    }
}

impl Default for Metric {
    fn default() -> Self {
        Metric {
            label: Vec::new(),
            gauge: None,
            counter: None,
            summary: None,
            untyped: None,
            histogram: None,
            timestamp_ms: None,
        }
    }
}

impl std::fmt::Debug for Metric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Metric {{ label: {:?}, gauge: {:?}, counter: {:?}, summary: {:?}, untyped: {:?}, histogram: {:?}, timestamp_ms: {:?} }}",
            self.label, self.gauge, self.counter, self.summary, self.untyped, self.histogram, self.timestamp_ms)
    }
}

use prost::Message;

#[derive(Clone, PartialEq, Message)]
pub struct MetricFamily {
    #[prost(string, optional, tag = "1")]
    pub name: Option<String>,
    #[prost(string, optional, tag = "2")]
    pub help: Option<String>,
    #[prost(enumeration = "MetricType", optional, tag = "3")]
    pub r#type: Option<i32>,
    #[prost(message, repeated, tag = "4")]
    pub metric: Vec<Metric>,
    #[prost(string, optional, tag = "5")]
    pub unit: Option<String>,
}

impl MetricFamily {
    pub fn reset(&mut self) {
        *self = MetricFamily::default();
    }

    pub fn get_name(&self) -> &str {
        self.name.as_deref().unwrap_or("")
    }

    pub fn get_help(&self) -> &str {
        self.help.as_deref().unwrap_or("")
    }

    pub fn get_type(&self) -> MetricType {
        self.r#type
            .map(|t| MetricType::from_i32(t).unwrap_or(MetricType::Counter))
            .unwrap_or(MetricType::Counter)
    }

    pub fn get_metric(&self) -> &Vec<Metric> {
        &self.metric
    }

    pub fn get_unit(&self) -> &str {
        self.unit.as_deref().unwrap_or("")
    }
}

impl Default for MetricFamily {
    fn default() -> Self {
        MetricFamily {
            name: None,
            help: None,
            r#type: None,
            metric: Vec::new(),
            unit: None,
        }
    }
}

impl std::fmt::Debug for MetricFamily {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "MetricFamily {{ name: {:?}, help: {:?}, type: {:?}, metric: {:?}, unit: {:?} }}",
            self.name, self.help, self.r#type, self.metric, self.unit
        )
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MetricType {
    Counter = 0,
    Gauge = 1,
    Summary = 2,
    Untyped = 3,
    Histogram = 4,
}

impl MetricType {
    pub fn from_i32(value: i32) -> Option<Self> {
        match value {
            0 => Some(MetricType::Counter),
            1 => Some(MetricType::Gauge),
            2 => Some(MetricType::Summary),
            3 => Some(MetricType::Untyped),
            4 => Some(MetricType::Histogram),
            _ => None,
        }
    }
}

use prost::alloc::sync::Arc;
use prost::bytes::Bytes;
use prost::Message;
use prost_types::FileDescriptorProto;
use std::sync::Once;

static FILE_DESCRIPTOR_PROTO_DATA: &[u8] = &[
    0x0a, 0x22, 0x69, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65, 0x75, 0x73, 0x2f,
    0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2f, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x70,
    0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x69, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68,
    0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67,
    0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65,
    0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x35, 0x0a, 0x09, 0x4c,
    0x61, 0x62, 0x65, 0x6c, 0x50, 0x61, 0x69, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x14, 0x0a, 0x05,
    0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c,
    0x75, 0x65, 0x22, 0x1d, 0x0a, 0x05, 0x47, 0x61, 0x75, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75,
    0x65, 0x22, 0xa4, 0x01, 0x0a, 0x07, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x12, 0x14, 0x0a,
    0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x76, 0x61,
    0x6c, 0x75, 0x65, 0x12, 0x3a, 0x0a, 0x08, 0x65, 0x78, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x72, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x69, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x6d, 0x65,
    0x74, 0x68, 0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x78, 0x65,
    0x6d, 0x70, 0x6c, 0x61, 0x72, 0x52, 0x08, 0x65, 0x78, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x72, 0x12,
    0x47, 0x0a, 0x11, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73,
    0x74, 0x61, 0x6d, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f,
    0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d,
    0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x10, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x54,
    0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x3c, 0x0a, 0x08, 0x51, 0x75, 0x61, 0x6e,
    0x74, 0x69, 0x6c, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x6c, 0x65,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x6c, 0x65,
    0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52,
    0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0xd0, 0x01, 0x0a, 0x07, 0x53, 0x75, 0x6d, 0x6d, 0x61,
    0x72, 0x79, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x5f, 0x63, 0x6f, 0x75,
    0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65,
    0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x5f,
    0x73, 0x75, 0x6d, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x09, 0x73, 0x61, 0x6d, 0x70, 0x6c,
    0x65, 0x53, 0x75, 0x6d, 0x12, 0x3a, 0x0a, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x6c, 0x65,
    0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x69, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x6d,
    0x65, 0x74, 0x68, 0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x51, 0x75,
    0x61, 0x6e, 0x74, 0x69, 0x6c, 0x65, 0x52, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x6c, 0x65,
    0x12, 0x47, 0x0a, 0x11, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65,
    0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f,
    0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69,
    0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x10, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64,
    0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x1f, 0x0a, 0x07, 0x55, 0x6e, 0x74,
    0x79, 0x70, 0x65, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x01, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0xea, 0x05, 0x0a, 0x09, 0x48,
    0x69, 0x73, 0x74, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x61, 0x6d, 0x70,
    0x6c, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0b,
    0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x2c, 0x0a, 0x12, 0x73,
    0x61, 0x6d, 0x70, 0x6c, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x66, 0x6c, 0x6f, 0x61,
    0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x52, 0x10, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x43,
    0x6f, 0x75, 0x6e, 0x74, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x61, 0x6d,
    0x70, 0x6c, 0x65, 0x5f, 0x73, 0x75, 0x6d, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x09, 0x73,
    0x61, 0x6d, 0x70, 0x6c, 0x65, 0x53, 0x75, 0x6d, 0x12, 0x34, 0x0a, 0x06, 0x62, 0x75, 0x63, 0x6b,
    0x65, 0x74, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x69, 0x6f, 0x2e, 0x70, 0x72,
    0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e,
    0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x52, 0x06, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x47,
    0x0a, 0x11, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74,
    0x61, 0x6d, 0x70, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
    0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
    0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x10, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x54, 0x69,
    0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6d,
    0x61, 0x18, 0x05, 0x20, 0x01, 0x28, 0x11, 0x52, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x12,
    0x25, 0x0a, 0x0e, 0x7a, 0x65, 0x72, 0x6f, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c,
    0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0d, 0x7a, 0x65, 0x72, 0x6f, 0x54, 0x68, 0x72,
    0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x7a, 0x65, 0x72, 0x6f, 0x5f, 0x63,
    0x6f, 0x75, 0x6e, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x7a, 0x65, 0x72, 0x6f,
    0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x28, 0x0a, 0x10, 0x7a, 0x65, 0x72, 0x6f, 0x5f, 0x63, 0x6f,
    0x75, 0x6e, 0x74, 0x5f, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x01, 0x52,
    0x0e, 0x7a, 0x65, 0x72, 0x6f, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x12,
    0x45, 0x0a, 0x0d, 0x6e, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x73, 0x70, 0x61, 0x6e,
    0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x69, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x6d,
    0x65, 0x74, 0x68, 0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x42, 0x75,
    0x63, 0x6b, 0x65, 0x74, 0x53, 0x70, 0x61, 0x6e, 0x52, 0x0c, 0x6e, 0x65, 0x67, 0x61, 0x74, 0x69,
    0x76, 0x65, 0x53, 0x70, 0x61, 0x6e, 0x12, 0x25, 0x0a, 0x0e, 0x6e, 0x65, 0x67, 0x61, 0x74, 0x69,
    0x76, 0x65, 0x5f, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x12, 0x52, 0x0d,
    0x6e, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x44, 0x65, 0x6c, 0x74, 0x61, 0x12, 0x25, 0x0a,
    0x0e, 0x6e, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18,
    0x0b, 0x20, 0x03, 0x28, 0x01, 0x52, 0x0d, 0x6e, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x43,
    0x6f, 0x75, 0x6e, 0x74, 0x12, 0x45, 0x0a, 0x0d, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65,
    0x5f, 0x73, 0x70, 0x61, 0x6e, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x69, 0x6f,
    0x2e, 0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x2e, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x53, 0x70, 0x61, 0x6e, 0x52, 0x0c, 0x70,
    0x6f, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x53, 0x70, 0x61, 0x6e, 0x12, 0x25, 0x0a, 0x0e, 0x70,
    0x6f, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x18, 0x0d, 0x20,
    0x03, 0x28, 0x12, 0x52, 0x0d, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x44, 0x65, 0x6c,
    0x74, 0x61, 0x12, 0x25, 0x0a, 0x0e, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x63,
    0x6f, 0x75, 0x6e, 0x74, 0x18, 0x0e, 0x20, 0x03, 0x28, 0x01, 0x52, 0x0d, 0x70, 0x6f, 0x73, 0x69,
    0x74, 0x69, 0x76, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x3c, 0x0a, 0x09, 0x65, 0x78, 0x65,
    0x6d, 0x70, 0x6c, 0x61, 0x72, 0x73, 0x18, 0x10, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x69,
    0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x2e, 0x45, 0x78, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x72, 0x52, 0x09, 0x65, 0x78,
    0x65, 0x6d, 0x70, 0x6c, 0x61, 0x72, 0x73, 0x22, 0xc6, 0x01, 0x0a, 0x06, 0x42, 0x75, 0x63, 0x6b,
    0x65, 0x74, 0x12, 0x29, 0x0a, 0x10, 0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65,
    0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0f, 0x63, 0x75,
    0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x34, 0x0a,
    0x16, 0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e,
    0x74, 0x5f, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x52, 0x14, 0x63,
    0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x46, 0x6c,
    0x6f, 0x61, 0x74, 0x12, 0x1f, 0x0a, 0x0b, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x62, 0x6f, 0x75,
    0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0a, 0x75, 0x70, 0x70, 0x65, 0x72, 0x42,
    0x6f, 0x75, 0x6e, 0x64, 0x12, 0x3a, 0x0a, 0x08, 0x65, 0x78, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x72,
    0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x69, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x6d,
    0x65, 0x74, 0x68, 0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x45, 0x78,
    0x65, 0x6d, 0x70, 0x6c, 0x61, 0x72, 0x52, 0x08, 0x65, 0x78, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x72,
    0x22, 0x3c, 0x0a, 0x0a, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x53, 0x70, 0x61, 0x6e, 0x12, 0x16,
    0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x11, 0x52, 0x06,
    0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x22, 0x91,
    0x01, 0x0a, 0x08, 0x45, 0x78, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x72, 0x12, 0x35, 0x0a, 0x05, 0x6c,
    0x61, 0x62, 0x65, 0x6c, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x69, 0x6f, 0x2e,
    0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x50, 0x61, 0x69, 0x72, 0x52, 0x05, 0x6c, 0x61, 0x62,
    0x65, 0x6c, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x01, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x38, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65,
    0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f,
    0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69,
    0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
    0x6d, 0x70, 0x22, 0xff, 0x02, 0x0a, 0x06, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x12, 0x35, 0x0a,
    0x05, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x69,
    0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x50, 0x61, 0x69, 0x72, 0x52, 0x05, 0x6c,
    0x61, 0x62, 0x65, 0x6c, 0x12, 0x31, 0x0a, 0x05, 0x67, 0x61, 0x75, 0x67, 0x65, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x69, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68,
    0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x47, 0x61, 0x75, 0x67, 0x65,
    0x52, 0x05, 0x67, 0x61, 0x75, 0x67, 0x65, 0x12, 0x37, 0x0a, 0x07, 0x63, 0x6f, 0x75, 0x6e, 0x74,
    0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x69, 0x6f, 0x2e, 0x70, 0x72,
    0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e,
    0x43, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x52, 0x07, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72,
    0x12, 0x37, 0x0a, 0x07, 0x73, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x1d, 0x2e, 0x69, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65, 0x75,
    0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79,
    0x52, 0x07, 0x73, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x12, 0x37, 0x0a, 0x07, 0x75, 0x6e, 0x74,
    0x79, 0x70, 0x65, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x69, 0x6f, 0x2e,
    0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x2e, 0x55, 0x6e, 0x74, 0x79, 0x70, 0x65, 0x64, 0x52, 0x07, 0x75, 0x6e, 0x74, 0x79, 0x70,
    0x65, 0x64, 0x12, 0x3d, 0x0a, 0x09, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x18,
    0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x69, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x6d, 0x65,
    0x74, 0x68, 0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x48, 0x69, 0x73,
    0x74, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x52, 0x09, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x67, 0x72, 0x61,
    0x6d, 0x12, 0x21, 0x0a, 0x0c, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x5f, 0x6d,
    0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
    0x6d, 0x70, 0x4d, 0x73, 0x22, 0xb6, 0x01, 0x0a, 0x0c, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x46,
    0x61, 0x6d, 0x69, 0x6c, 0x79, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x68, 0x65, 0x6c,
    0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x68, 0x65, 0x6c, 0x70, 0x12, 0x34, 0x0a,
    0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x20, 0x2e, 0x69, 0x6f,
    0x2e, 0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x2e, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74,
    0x79, 0x70, 0x65, 0x12, 0x34, 0x0a, 0x06, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x18, 0x04, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x69, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68,
    0x65, 0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x2e, 0x4d, 0x65, 0x74, 0x72, 0x69,
    0x63, 0x52, 0x06, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x6e, 0x69,
    0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x6e, 0x69, 0x74, 0x2a, 0x62, 0x0a,
    0x0a, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0b, 0x0a, 0x07, 0x43,
    0x4f, 0x55, 0x4e, 0x54, 0x45, 0x52, 0x10, 0x00, 0x12, 0x09, 0x0a, 0x05, 0x47, 0x41, 0x55, 0x47,
    0x45, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x53, 0x55, 0x4d, 0x4d, 0x41, 0x52, 0x59, 0x10, 0x02,
    0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x54, 0x59, 0x50, 0x45, 0x44, 0x10, 0x03, 0x12, 0x0d, 0x0a,
    0x09, 0x48, 0x49, 0x53, 0x54, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x10, 0x04, 0x12, 0x13, 0x0a, 0x0f,
    0x47, 0x41, 0x55, 0x47, 0x45, 0x5f, 0x48, 0x49, 0x53, 0x54, 0x4f, 0x47, 0x52, 0x41, 0x4d, 0x10,
    0x05, 0x42, 0x52, 0x0a, 0x14, 0x69, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65,
    0x75, 0x73, 0x2e, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5a, 0x3a, 0x67, 0x69, 0x74, 0x68, 0x75,
    0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65, 0x75, 0x73,
    0x2f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x2f, 0x67, 0x6f,
    0x3b, 0x69, 0x6f, 0x5f, 0x70, 0x72, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x65, 0x75, 0x73, 0x5f, 0x63,
    0x6c, 0x69, 0x65, 0x6e, 0x74,
];

static mut FILE_DESCRIPTOR_PROTO: Option<Arc<FileDescriptorProto>> = None;
static INIT: Once = Once::new();

pub fn file_descriptor_proto() -> Arc<FileDescriptorProto> {
    unsafe {
        INIT.call_once(|| {
            let proto = FileDescriptorProto::decode(Bytes::from_static(FILE_DESCRIPTOR_PROTO_DATA))
                .unwrap();
            FILE_DESCRIPTOR_PROTO = Some(Arc::new(proto));
        });
        FILE_DESCRIPTOR_PROTO.clone().unwrap()
    }
}

use once_cell::sync::Lazy;
use prost::Message;
use std::sync::Once;

static FILE_IO_PROMETHEUS_CLIENT_METRICS_PROTO_RAW_DESC_ONCE: Once = Once::new();
static mut FILE_IO_PROMETHEUS_CLIENT_METRICS_PROTO_RAW_DESC_DATA: Vec<u8> = Vec::new();

fn file_io_prometheus_client_metrics_proto_raw_desc_gzip() -> &'static [u8] {
    unsafe {
        FILE_IO_PROMETHEUS_CLIENT_METRICS_PROTO_RAW_DESC_ONCE.call_once(|| {
            FILE_IO_PROMETHEUS_CLIENT_METRICS_PROTO_RAW_DESC_DATA =
                compress_gzip(&FILE_IO_PROMETHEUS_CLIENT_METRICS_PROTO_RAW_DESC_DATA);
        });
        &FILE_IO_PROMETHEUS_CLIENT_METRICS_PROTO_RAW_DESC_DATA
    }
}

fn compress_gzip(data: &[u8]) -> Vec<u8> {
    use flate2::write::GzEncoder;
    use flate2::Compression;
    use std::io::prelude::*;

    let mut encoder = GzEncoder::new(Vec::new(), Compression::default());
    encoder.write_all(data).expect("Failed to write data");
    encoder.finish().expect("Failed to finish compression")
}

static FILE_IO_PROMETHEUS_CLIENT_METRICS_PROTO_ENUM_TYPES: Lazy<Vec<MetricType>> =
    Lazy::new(|| vec![MetricType::default()]);
static FILE_IO_PROMETHEUS_CLIENT_METRICS_PROTO_MSG_TYPES: Lazy<Vec<Message>> = Lazy::new(|| {
    vec![
        LabelPair::default(),
        Gauge::default(),
        Counter::default(),
        Quantile::default(),
        Summary::default(),
        Untyped::default(),
        Histogram::default(),
        Bucket::default(),
        BucketSpan::default(),
        Exemplar::default(),
        Metric::default(),
        MetricFamily::default(),
    ]
});

static FILE_IO_PROMETHEUS_CLIENT_METRICS_PROTO_GO_TYPES: Lazy<Vec<Box<dyn prost::Message>>> =
    Lazy::new(|| {
        vec![
            Box::new(LabelPair::default()),
            Box::new(Gauge::default()),
            Box::new(Counter::default()),
            Box::new(Quantile::default()),
            Box::new(Summary::default()),
            Box::new(Untyped::default()),
            Box::new(Histogram::default()),
            Box::new(Bucket::default()),
            Box::new(BucketSpan::default()),
            Box::new(Exemplar::default()),
            Box::new(Metric::default()),
            Box::new(MetricFamily::default()),
        ]
    });

static FILE_IO_PROMETHEUS_CLIENT_METRICS_PROTO_DEP_IDXS: Lazy<Vec<i32>> = Lazy::new(|| {
    vec![
        10, // Counter.exemplar -> Exemplar
        13, // Counter.created_timestamp -> Timestamp
        4,  // Summary.quantile -> Quantile
        13, // Summary.created_timestamp -> Timestamp
        8,  // Histogram.bucket -> Bucket
        13, // Histogram.created_timestamp -> Timestamp
        9,  // Histogram.negative_span -> BucketSpan
        9,  // Histogram.positive_span -> BucketSpan
        10, // Histogram.exemplars -> Exemplar
        10, // Bucket.exemplar -> Exemplar
        1,  // Exemplar.label -> LabelPair
        13, // Exemplar.timestamp -> Timestamp
        1,  // Metric.label -> LabelPair
        2,  // Metric.gauge -> Gauge
        3,  // Metric.counter -> Counter
        5,  // Metric.summary -> Summary
        6,  // Metric.untyped -> Untyped
        7,  // Metric.histogram -> Histogram
        0,  // MetricFamily.type -> MetricType
        11, // MetricFamily.metric -> Metric
    ]
});

use once_cell::sync::Lazy;
use prost::Message;
use std::sync::Once;

static FILE_IO_PROMETHEUS_CLIENT_METRICS_PROTO_INIT: Once = Once::new();
static mut FILE_IO_PROMETHEUS_CLIENT_METRICS_PROTO: Option<prost::MessageDescriptor> = None;

fn init() {
    file_io_prometheus_client_metrics_proto_init();
}

fn file_io_prometheus_client_metrics_proto_init() {
    unsafe {
        if FILE_IO_PROMETHEUS_CLIENT_METRICS_PROTO.is_some() {
            return;
        }

        if !protoimpl::UNSAFE_ENABLED {
            file_io_prometheus_client_metrics_proto_msg_types[0].exporter = Some(|v: &dyn Message, i: usize| match i {
                0 => &v.state,
                1 => &v.size_cache,
                2 => &v.unknown_fields,
                _ => None,
            });

            file_io_prometheus_client_metrics_proto_msg_types[1].exporter = Some(|v: &dyn Message, i: usize| match i {
                0 => &v.state,
                1 => &v.size_cache,
                2 => &v.unknown_fields,
                _ => None,
            });

            file_io_prometheus_client_metrics_proto_msg_types[2].exporter = Some(|v: &dyn Message, i: usize| match i {
                0 => &v.state,
                1 => &v.size_cache,
                2 => &v.unknown_fields,
                _ => None,
            });

            file_io_prometheus_client_metrics_proto_msg_types[3].exporter = Some(|v: &dyn Message, i: usize| match i {
                0 => &v.state,
                1 => &v.size_cache,
                2 => &v.unknown_fields,
                _ => None,
            });

            file_io_prometheus_client_metrics_proto_msg_types[4].exporter = Some(|v: &dyn Message, i: usize| match i {
                0 => &v.state,
                1 => &v.size_cache,
                2 => &v.unknown_fields,
                _ => None,
            });

            file_io_prometheus_client_metrics_proto_msg_types[5].exporter = Some(|v: &dyn Message, i: usize| match i {
                0 => &v.state,
                1 => &v.size_cache,
                2 => &v.unknown_fields,
                _ => None,
            });

            file_io_prometheus_client_metrics_proto_msg_types[6].exporter = Some(|v: &dyn Message, i: usize| match i {
                0 => &v.state,
                1 => &v.size_cache,
                2 => &v.unknown_fields,
                _ => None,
            });

            file_io_prometheus_client_metrics_proto_msg_types[7].exporter = Some(|v: &dyn Message, i: usize| match i {
                0 => &v.state,
                1 => &v.size_cache,
                2 => &v.unknown_fields,
                _ => None,
            });

            file_io_prometheus_client_metrics_proto_msg_types[8].exporter = Some(|v: &dyn Message, i: usize| match i {
                0 => &v.state,
                1 => &v.size_cache,
                2 => &v.unknown_fields,
                _ => None,
            });

            file_io_prometheus_client_metrics_proto_msg_types[9].exporter = Some(|v: &dyn Message, i: usize| match i {
                0 => &v.state,
                1 => &v.size_cache,
                2 => &v.unknown_fields,
                _ => None,
            });

            file_io_prometheus_client_metrics_proto_msg_types[10].exporter = Some(|v: &dyn Message, i: usize| match i {
                0 => &v.state,
                1 => &v.size_cache,
                2 => &v.unknown_fields,
                _ => None,
            });

            file_io_prometheus_client_metrics_proto_msg_types[11].exporter = Some(|v: &dyn Message, i: usize| match i {
                0 => &v.state,
                1 => &v.size_cache,
                2 => &v.unknown_fields,
                _ => None,
            });
        }

        let out = protoimpl::TypeBuilder {
            file: protoimpl::DescBuilder {
                go_package_path: std::any::type_name::<x>(),
                raw_descriptor: file_io_prometheus_client_metrics_proto_raw_desc,
                num_enums: 1,
                num_messages: 12,
                num_extensions: 0,
                num_services: 0,
            },
            go_types: file_io_prometheus_client_metrics_proto_go_types,
            dependency_indexes: file_io_prometheus_client_metrics_proto_dep_idxs,
            enum_infos: file_io_prometheus_client_metrics_proto_enum_types,
            message_infos: file_io_prometheus_client_metrics_proto_msg_types,
        }
        .build();

        FILE_IO_PROMETHEUS_CLIENT_METRICS_PROTO = Some(out.file);
        file_io_prometheus_client_metrics_proto_raw_desc = None;
        file_io_prometheus_client_metrics_proto_go_types = None;
        file_io_prometheus_client_metrics_proto_dep_idxs = None;
    }
}

struct x;

mod protoimpl {
    use prost::Message;

    pub const UNSAFE_ENABLED: bool = false;

    pub struct TypeBuilder {
        pub file: DescBuilder,
        pub go_types: Vec<Box<dyn Message>>,
        pub dependency_indexes: Vec<i32>,
        pub enum_infos: Vec<EnumInfo>,
        pub message_infos: Vec<MessageInfo>,
    }

    impl TypeBuilder {
        pub fn build(self) -> TypeBuilder {
            self
        }
    }

    pub struct DescBuilder {
        pub go_package_path: &'static str,
        pub raw_descriptor: &'static [u8],
        pub num_enums: usize,
        pub num_messages: usize,
        pub num_extensions: usize,
        pub num_services: usize,
    }

    pub struct EnumInfo;

    pub struct MessageInfo {
        pub exporter: Option<fn(&dyn Message, usize) -> Option<&dyn std::any::Any>>,
    }
}